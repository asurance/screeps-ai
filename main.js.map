{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/command/build.ts","webpack:///./src/command/command.ts","webpack:///./src/command/harvest.ts","webpack:///./src/command/pickup.ts","webpack:///./src/command/repair.ts","webpack:///./src/command/transfer.ts","webpack:///./src/command/upgradeController.ts","webpack:///./src/command/withdraw.ts","webpack:///./src/config.ts","webpack:///./src/index.ts","webpack:///./src/moveCache.ts","webpack:///./src/patch.ts","webpack:///./src/roomInfo.ts","webpack:///./src/strategy/harvester.ts","webpack:///./src/strategy/transferer.ts","webpack:///./src/strategy/worker.ts","webpack:///./src/util.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,uCAAS;AACjC,kBAAkB,mBAAO,CAAC,2CAAW;AACrC,iBAAiB,mBAAO,CAAC,yCAAU;AACnC,iBAAiB,mBAAO,CAAC,yCAAU;AACnC,mBAAmB,mBAAO,CAAC,6CAAY;AACvC,4BAA4B,mBAAO,CAAC,+DAAqB;AACzD,mBAAmB,mBAAO,CAAC,6CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA,oEAAoE,WAAW;AAC/E;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,kCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;;;;;;;;;;;;;ACflD;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAO,CAAC,+BAAS;AACjB,oBAAoB,mBAAO,CAAC,yDAAsB;AAClD,kBAAkB,mBAAO,CAAC,mDAAmB;AAC7C,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,eAAe,mBAAO,CAAC,6BAAQ;AAC/B,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,4BAA4B,mBAAO,CAAC,uEAA6B;AACjE,mBAAmB,mBAAO,CAAC,qDAAoB;AAC/C,iBAAiB,mBAAO,CAAC,iDAAkB;AAC3C,qBAAqB,mBAAO,CAAC,2DAAuB;AACpD,iBAAiB,mBAAO,CAAC,mDAAmB;AAC5C,mBAAmB,mBAAO,CAAC,qDAAoB;AAC/C,gBAAgB,mBAAO,CAAC,+CAAiB;AACzC,iBAAiB,mBAAO,CAAC,iDAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW,GAAG,QAAQ,GAAG,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnJa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,oDAAoB;AAC9C,eAAe,mBAAO,CAAC,8BAAS;AAChC,mBAAmB,mBAAO,CAAC,sCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ca;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,oDAAoB;AAC9C,oBAAoB,mBAAO,CAAC,wCAAc;AAC1C,eAAe,mBAAO,CAAC,8BAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpHa;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,oDAAoB;AAC9C,oBAAoB,mBAAO,CAAC,wCAAc;AAC1C,eAAe,mBAAO,CAAC,8BAAS;AAChC,YAAY,mBAAO,CAAC,2BAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,+DAA+D,oDAAoD;AACnH;AACA,0DAA0D,0CAA0C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oDAAoD;AAC1G,iDAAiD,0CAA0C;AAC3F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Pa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Build = exports.SetCreepBuild = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 建造前\n * @param creep Creep\n * @param target 目标\n */\nfunction SetCreepBuild(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepBuild = SetCreepBuild;\n/**\n * 建造\n * @param creep Creep\n */\nfunction Build(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            if (target.progress < target.progressTotal) {\n                if (creep.pos.inRangeTo(target, 3)) {\n                    const result = creep.build(target);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    if (creep.fatigue <= 0) {\n                        const result = creep.moveTo(target, { range: 3 });\n                        if (result !== OK) {\n                            Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                        }\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\nexports.Build = Build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetNextCommand = void 0;\nconst build_1 = require(\"./build\");\nconst harvest_1 = require(\"./harvest\");\nconst pickup_1 = require(\"./pickup\");\nconst repair_1 = require(\"./repair\");\nconst transfer_1 = require(\"./transfer\");\nconst upgradeController_1 = require(\"./upgradeController\");\nconst withdraw_1 = require(\"./withdraw\");\n/**\n * 设置命令表\n */\nconst SetCommandMap = {\n    [\"harvest\" /* Harvest */]: harvest_1.SetCreepHarvest,\n    [\"updateController\" /* UpgradeController */]: upgradeController_1.SetCreepUpgradeController,\n    [\"transfer\" /* Transfer */]: transfer_1.SetCreepTransfer,\n    [\"pickup\" /* Pickup */]: pickup_1.SetCreepPickup,\n    [\"withdraw\" /* Withdraw */]: withdraw_1.SetCreepWithdraw,\n    [\"build\" /* Build */]: build_1.SetCreepBuild,\n    [\"repair\" /* Repair */]: repair_1.SetCreepRepair,\n};\n/**\n * 设置creep命令\n * @param command 命令\n * @param creep creep\n * @param argv 剩余参数\n */\nfunction SetNextCommand(command, creep, ...argv) {\n    delete creep.memory.cmd;\n    creep.memory.cmd = {\n        type: command\n    };\n    // @ts-expect-error ts暂时无法识别该类型\n    SetCommandMap[command](creep, ...argv);\n}\nexports.SetNextCommand = SetNextCommand;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Harvest = exports.SetCreepHarvest = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 收获前\n * @param creep Creep\n * @param target 目标\n */\nfunction SetCreepHarvest(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepHarvest = SetCreepHarvest;\n/**\n * 收获\n * @param creep Creep\n * @return 收获结果\n */\nfunction Harvest(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (target.energy > 0 || target.ticksToRegeneration < 100) {\n            if (creep.pos.inRangeTo(target.pos, 1)) {\n                if (target.energy > 0) {\n                    const result = creep.harvest(target);\n                    if (result !== OK) {\n                        Game.notify(`harvest fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                }\n                return 0 /* OK */;\n            }\n            else {\n                if (creep.fatigue <= 0) {\n                    const result = creep.moveTo(target, { range: 1 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                }\n                return 1 /* Moving */;\n            }\n        }\n        else {\n            return 3 /* TargetNeedReplace */;\n        }\n    }\n    else {\n        return 2 /* TargetLost */;\n    }\n}\nexports.Harvest = Harvest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pickup = exports.SetCreepPickup = void 0;\nconst config_1 = require(\"../config\");\nfunction SetCreepPickup(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepPickup = SetCreepPickup;\n/**\n * 捡起\n * @param creep Creep\n */\nfunction Pickup(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n            if (target.amount > 0) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.pickup(target);\n                    if (result !== OK) {\n                        Game.notify(`pickup fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    if (creep.fatigue <= 0) {\n                        const result = creep.moveTo(target, { range: 1 });\n                        if (result !== OK) {\n                            Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                        }\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* Full */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\nexports.Pickup = Pickup;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Repair = exports.SetCreepRepair = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 维修前\n * @param creep Creep\n * @param target 目标\n */\nfunction SetCreepRepair(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepRepair = SetCreepRepair;\n/**\n * 维修\n * @param creep Creep\n */\nfunction Repair(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            if (target.hits < target.hitsMax) {\n                if (creep.pos.inRangeTo(target, 3)) {\n                    const result = creep.repair(target);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    if (creep.fatigue <= 0) {\n                        const result = creep.moveTo(target, { range: 3 });\n                        if (result !== OK) {\n                            Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                        }\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\nexports.Repair = Repair;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.SetCreepTransfer = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 转移前\n * @param creep Creep\n * @param target 转移目标\n */\nfunction SetCreepTransfer(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepTransfer = SetCreepTransfer;\n/**\n * 转移\n * @param creep Creep\n */\nfunction Transfer(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            let hasRest = false;\n            switch (target.structureType) {\n                case STRUCTURE_EXTENSION:\n                case STRUCTURE_SPAWN:\n                case STRUCTURE_TOWER:\n                    hasRest = target.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                    break;\n                case STRUCTURE_CONTAINER:\n                case STRUCTURE_STORAGE:\n                    hasRest = target.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                    break;\n            }\n            if (hasRest) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.transfer(target, RESOURCE_ENERGY);\n                    if (result !== OK) {\n                        Game.notify(`transfer fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    if (creep.fatigue <= 0) {\n                        const result = creep.moveTo(target, { range: 1 });\n                        if (result !== OK) {\n                            Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                        }\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\nexports.Transfer = Transfer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateController = exports.SetCreepUpgradeController = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 升级控制器前\n * @param creep Creep\n */\nfunction SetCreepUpgradeController() {\n    // TODO 暂时没有需要做的\n}\nexports.SetCreepUpgradeController = SetCreepUpgradeController;\nfunction UpdateController(creep) {\n    if (creep.store.energy > 0) {\n        if (creep.pos.inRangeTo(creep.room.controller, 3)) {\n            const result = creep.upgradeController(creep.room.controller);\n            if (result !== OK) {\n                Game.notify(`upgradeController fail with code:${result}`, config_1.config.notifyInterval);\n            }\n            return 0 /* OK */;\n        }\n        else {\n            if (creep.fatigue <= 0) {\n                const result = creep.moveTo(creep.room.controller, { range: 3 });\n                if (result !== OK) {\n                    Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                }\n            }\n            return 1 /* Moving */;\n        }\n    }\n    else {\n        return 2 /* RequireMoreEnergy */;\n    }\n}\nexports.UpdateController = UpdateController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdraw = exports.SetCreepWithdraw = void 0;\nconst config_1 = require(\"../config\");\n/**\n * 取回前\n * @param creep Creep\n * @param target 目标\n */\nfunction SetCreepWithdraw(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\nexports.SetCreepWithdraw = SetCreepWithdraw;\n/**\n * 取回\n * @param creep Creep\n */\nfunction Withdraw(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n            if (target.store.energy > 0) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.withdraw(target, RESOURCE_ENERGY);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config_1.config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    if (creep.fatigue <= 0) {\n                        const result = creep.moveTo(target, { range: 1 });\n                        if (result !== OK) {\n                            Game.notify(`move fail with code:${result}`, config_1.config.notifyInterval);\n                        }\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* Full */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\nexports.Withdraw = Withdraw;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.config = void 0;\n/**\n * 默认配置\n */\nconst defualtConfig = {\n    notifyInterval: 24 * 60,\n    harvester: 2,\n    transferer: 8,\n    worker: 5,\n};\n/**\n * 项目采用配置\n */\nexports.config = Memory.config ? Object.assign(Object.assign({}, defualtConfig), Memory.config) : defualtConfig;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loop = exports.creepInfo = void 0;\nrequire(\"./patch\");\nconst harvester_1 = require(\"./strategy/harvester\");\nconst harvest_1 = require(\"./command/harvest\");\nconst config_1 = require(\"./config\");\nconst util_1 = require(\"./util\");\nconst roomInfo_1 = require(\"./roomInfo\");\nconst upgradeController_1 = require(\"./command/upgradeController\");\nconst transfer_1 = require(\"./command/transfer\");\nconst pickup_1 = require(\"./command/pickup\");\nconst transferer_1 = require(\"./strategy/transferer\");\nconst worker_1 = require(\"./strategy/worker\");\nconst withdraw_1 = require(\"./command/withdraw\");\nconst build_1 = require(\"./command/build\");\nconst repair_1 = require(\"./command/repair\");\n/**\n * creep信息\n */\nexports.creepInfo = CreateCreepInfo();\nfunction CreateCreepInfo() {\n    var _a, _b;\n    const creepInfo = new Map();\n    // 数据预处理\n    for (const creepName in Game.creeps) {\n        const creep = Game.creeps[creepName];\n        let map = creepInfo.get(creep.memory.strategy.type);\n        if (!map) {\n            map = new Map();\n            creepInfo.set(creep.memory.strategy.type, map);\n        }\n        const key = (_b = (_a = creep.memory.cmd) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : null;\n        const list = map.get(key);\n        if (list) {\n            list.push(creep);\n        }\n        else {\n            map.set(key, [creep]);\n        }\n    }\n    return creepInfo;\n}\nfunction loop() {\n    const spawn = Game.spawns['Home'];\n    // 回收多余cpu资源\n    if (Game.cpu.bucket >= PIXEL_CPU_COST + 1000) {\n        Game.cpu.generatePixel();\n    }\n    // 删除过期数据\n    for (const key in Memory.creeps) {\n        if (!(key in Game.creeps)) {\n            delete Memory.creeps[key];\n            roomInfo_1.OnCreepDead(spawn.room, key);\n        }\n    }\n    exports.creepInfo = CreateCreepInfo();\n    // 数据\n    const strategyMap = {\n        harvester: harvester_1.Harvester,\n        transferer: transferer_1.Transferer,\n        worker: worker_1.Worker,\n    };\n    const commandMap = {\n        harvest: harvest_1.Harvest,\n        updateController: upgradeController_1.UpdateController,\n        transfer: transfer_1.Transfer,\n        pickup: pickup_1.Pickup,\n        withdraw: withdraw_1.Withdraw,\n        build: build_1.Build,\n        repair: repair_1.Repair,\n    };\n    // 塔设置\n    const towers = spawn.room.find(FIND_STRUCTURES, {\n        filter: (structure) => structure.structureType === STRUCTURE_TOWER\n            && structure.my\n    });\n    towers.forEach(tower => {\n        const hostTile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n        if (hostTile) {\n            hostTile.attack(hostTile);\n        }\n    });\n    // creep操作\n    for (const name in Game.creeps) {\n        const creep = Game.creeps[name];\n        if (!creep.spawning) {\n            const strategy = strategyMap[creep.memory.strategy.type];\n            if (creep.memory.cmd) {\n                const commandType = creep.memory.cmd.type;\n                if (commandType in strategy.callbackMap) {\n                    // @ts-expect-error ts暂时无法识别该类型\n                    strategy.callbackMap[commandType](creep, commandMap[commandType](creep));\n                }\n                else {\n                    commandMap[commandType](creep);\n                }\n            }\n            else {\n                strategy.start(creep);\n            }\n        }\n    }\n    // 生成新creep\n    if (!spawn.spawning) {\n        let spawing = null;\n        let list = [\"harvester\" /* Harvester */, \"transferer\" /* Transferer */, \"worker\" /* Worker */];\n        for (let i = 0; i < list.length; i++) {\n            const map = exports.creepInfo.get(list[i]);\n            if (map) {\n                let sum = 0;\n                map.forEach(v => sum += v.length);\n                if (sum >= config_1.config[list[i]]) {\n                    list.splice(i, 1);\n                    i--;\n                }\n            }\n            else {\n                spawing = list[i];\n                break;\n            }\n        }\n        if (spawing) {\n            if (spawn.room.energyAvailable < strategyMap[spawing].minEnergy) {\n                spawing = null;\n            }\n        }\n        else {\n            list = list.filter(s => spawn.room.energyAvailable >= strategyMap[s].minEnergy);\n            spawing = util_1.RandomObjectInList(list);\n        }\n        if (spawing) {\n            const name = `${spawn.name}-${spawing}-${Game.time}`;\n            const result = spawn.spawnCreep(strategyMap[spawing].create(spawn.room.energyAvailable), name);\n            if (result === OK) {\n                const creep = Game.creeps[name];\n                creep.memory.strategy = {\n                    type: spawing\n                };\n                strategyMap[spawing].initStrategy(creep);\n            }\n            else {\n                Game.notify(`spawn creep fail with code:${result}`, config_1.config.notifyInterval);\n            }\n        }\n    }\n}\nexports.loop = loop;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkMoveFail = exports.initMoveCache = void 0;\n/**\n * 初始化移动缓存\n * @param creep Creep\n * @return 初始移动缓存数据\n */\nfunction initMoveCache(creep) {\n    return {\n        pos: creep.pos.x + creep.pos.y * 50,\n        ticker: 60,\n    };\n}\nexports.initMoveCache = initMoveCache;\n/**\n * 检测移动失效\n * @param creep Creep\n * @param data 移动缓存数据\n * @return 是否失效\n */\nfunction checkMoveFail(creep, data) {\n    const x = data.pos % 50;\n    const y = Math.floor(data.pos / 50);\n    if (creep.pos.inRangeTo(x, y, 3)) {\n        data.ticker--;\n        if (data.ticker <= 0) {\n            data.ticker = 30;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        data.pos = creep.pos.x + creep.pos.y * 50;\n        data.ticker = 30;\n        return false;\n    }\n}\nexports.checkMoveFail = checkMoveFail;\n","\"use strict\";\nGame.killAllCreeps = () => {\n    for (const name in Game.creeps) {\n        Game.creeps[name].suicide();\n        delete Memory.creeps[name];\n    }\n};\nGame.clearRoomInfo = () => {\n    for (const name in Memory.rooms) {\n        delete Memory.rooms[name];\n    }\n};\nGame.Restart = () => {\n    Game.clearRoomInfo();\n    Game.killAllCreeps();\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OnCreepDead = exports.GetRoomInfo = void 0;\n/**\n * 获取房间信息\n * @param room 房间\n */\nfunction GetRoomInfo(room) {\n    if (!room.memory.sourceInfo) {\n        room.memory.sourceInfo = room.find(FIND_SOURCES).map(source => source.id);\n        room.memory.creepInfo = new Array(room.memory.sourceInfo.length).fill(null);\n    }\n    return room.memory;\n}\nexports.GetRoomInfo = GetRoomInfo;\nfunction OnCreepDead(room, creepName) {\n    if (room.memory.creepInfo) {\n        const index = room.memory.creepInfo.indexOf(creepName);\n        if (index >= 0) {\n            room.memory.creepInfo.splice(index, 1);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nexports.OnCreepDead = OnCreepDead;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Harvester = void 0;\nconst command_1 = require(\"../command/command\");\nconst util_1 = require(\"../util\");\nconst roomInfo_1 = require(\"../roomInfo\");\n/**\n * 采集者策略\n */\nexports.Harvester = {\n    minEnergy: util_1.GetRequiredEnergy([MOVE, WORK]),\n    create(maxEnergy) {\n        const count = Math.min(6, Math.floor((maxEnergy - this.minEnergy) / BODYPART_COST.work));\n        const body = [MOVE, WORK];\n        body.splice(0, 0, ...new Array(count).fill(WORK));\n        return body;\n    },\n    initStrategy() {\n        // TODO\n    },\n    start(creep) {\n        FindNextTarget(creep);\n    },\n    callbackMap: {},\n};\n/**\n * 找到下一个采集目标\n * @param creep creep\n * @return 是否成功\n */\nfunction FindNextTarget(creep) {\n    const roomInfos = roomInfo_1.GetRoomInfo(creep.room);\n    for (let i = 0; i < roomInfos.sourceInfo.length; i++) {\n        if (roomInfos.creepInfo[i] === null) {\n            const target = Game.getObjectById(roomInfos.sourceInfo[i]);\n            if (target) {\n                command_1.SetNextCommand(\"harvest\" /* Harvest */, creep, target);\n                roomInfos.creepInfo[i] = creep.name;\n                return true;\n            }\n        }\n    }\n    creep.say('闲置中');\n    return false;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transferer = void 0;\nconst command_1 = require(\"../command/command\");\nconst moveCache_1 = require(\"../moveCache\");\nconst util_1 = require(\"../util\");\n/**\n * 运输者\n */\nexports.Transferer = {\n    minEnergy: util_1.GetRequiredEnergy([CARRY, MOVE]),\n    create(maxEnergy) {\n        let rest = maxEnergy - this.minEnergy;\n        const body = [CARRY, MOVE];\n        if (rest >= BODYPART_COST.carry) {\n            body.unshift(CARRY);\n            rest -= BODYPART_COST.carry;\n        }\n        const count = Math.floor(rest / (BODYPART_COST.carry * 2 + BODYPART_COST.move));\n        for (let i = 0; i < count; i++) {\n            body.push(CARRY, CARRY, MOVE);\n        }\n        return body;\n    },\n    initStrategy(creep) {\n        const strategy = creep.memory.strategy;\n        strategy.moveCache = moveCache_1.initMoveCache(creep);\n    },\n    start(creep) {\n        FindPickupTarget(creep);\n    },\n    callbackMap: {\n        [\"pickup\" /* Pickup */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (!FindPickupTarget(creep) && creep.store.energy > 0) {\n                        FindTransferTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindPickupTarget(creep);\n                    }\n                    break;\n                case 2 /* Full */:\n                    FindTransferTarget(creep);\n                    break;\n            }\n        },\n        [\"transfer\" /* Transfer */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (!FindTransferTarget(creep)) {\n                        FindPickupTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindTransferTarget(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindPickupTarget(creep);\n                    break;\n            }\n        },\n    }\n};\n/**\n * 找到下一个捡起目标\n * @param creep creep\n */\nfunction FindPickupTarget(creep) {\n    const target = util_1.RandomObjectInList(creep.room.find(FIND_DROPPED_RESOURCES));\n    if (target) {\n        command_1.SetNextCommand(\"pickup\" /* Pickup */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\n/**\n * 找到下一个转移目标\n * @param creep creep\n */\nfunction FindTransferTarget(creep) {\n    const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n        filter: (structure => {\n            switch (structure.structureType) {\n                case STRUCTURE_EXTENSION:\n                case STRUCTURE_SPAWN:\n                case STRUCTURE_TOWER:\n                    return structure.my && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                case STRUCTURE_STORAGE:\n                    return structure.my && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                case STRUCTURE_CONTAINER:\n                    return structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n            }\n            return false;\n        }),\n        range: 1,\n    });\n    if (target) {\n        command_1.SetNextCommand(\"transfer\" /* Transfer */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Worker = void 0;\nconst command_1 = require(\"../command/command\");\nconst moveCache_1 = require(\"../moveCache\");\nconst util_1 = require(\"../util\");\nconst __1 = require(\"../\");\n/**\n * 采集者策略\n */\nexports.Worker = {\n    minEnergy: util_1.GetRequiredEnergy([MOVE, WORK, CARRY]),\n    create(maxEnergy) {\n        const count = Math.floor(maxEnergy / (BODYPART_COST.work + BODYPART_COST.move + BODYPART_COST.carry));\n        const body = [];\n        for (let i = 0; i < count; i++) {\n            body.push(MOVE, WORK, CARRY);\n        }\n        return body;\n    },\n    initStrategy(creep) {\n        const strategy = creep.memory.strategy;\n        strategy.moveCache = moveCache_1.initMoveCache(creep);\n    },\n    start(creep) {\n        FindWithdrawTarget(creep);\n    },\n    callbackMap: {\n        [\"withdraw\" /* Withdraw */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 2 /* Full */:\n                    FindNextWork(creep);\n                    break;\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindRandomWithdrawTarget(creep);\n                    }\n            }\n        },\n        [\"updateController\" /* UpgradeController */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n        [\"build\" /* Build */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 4 /* TargetNeedReplace */:\n                case 3 /* TargetLost */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n        [\"repair\" /* Repair */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 4 /* TargetNeedReplace */:\n                case 3 /* TargetLost */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (moveCache_1.checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n    },\n};\nfunction FindWithdrawTarget(creep) {\n    let target = creep.pos.findClosestByPath(FIND_TOMBSTONES, { filter: (tombstone) => tombstone.store.energy > 0 });\n    if (target === null) {\n        target = creep.pos.findClosestByPath(FIND_RUINS, { filter: (ruin) => ruin.store.energy > 0 });\n    }\n    if (target === null) {\n        target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n            filter: (structure) => ((structure.structureType === STRUCTURE_CONTAINER)\n                || (structure.structureType === STRUCTURE_STORAGE && structure.my))\n                && structure.store.energy > 0\n        });\n    }\n    if (target) {\n        command_1.SetNextCommand(\"withdraw\" /* Withdraw */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindRandomWithdrawTarget(creep) {\n    const targets = creep.room.find(FIND_TOMBSTONES, { filter: (tombstone) => tombstone.store.energy > 0 });\n    targets.push(...creep.room.find(FIND_RUINS, { filter: (ruin) => ruin.store.energy > 0 }));\n    targets.push(...creep.room.find(FIND_STRUCTURES, {\n        filter: (structure) => ((structure.structureType === STRUCTURE_CONTAINER)\n            || (structure.structureType === STRUCTURE_STORAGE && structure.my))\n            && structure.store.energy > 0\n    }));\n    const target = util_1.RandomObjectInList(targets);\n    if (target) {\n        command_1.SetNextCommand(\"withdraw\" /* Withdraw */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindBuildTarget(creep) {\n    const targets = creep.room.find(FIND_CONSTRUCTION_SITES, {\n        filter: (constructionSite) => constructionSite.progress < constructionSite.progressTotal\n    });\n    if (targets.length > 0) {\n        const target = targets.reduce((pre, cur) => {\n            if (pre.progressTotal < cur.progressTotal / 10) {\n                return pre;\n            }\n            else if (cur.progressTotal < pre.progressTotal / 10) {\n                return cur;\n            }\n            else {\n                return pre.progress / pre.progressTotal > cur.progress / cur.progressTotal ?\n                    pre : cur;\n            }\n        });\n        command_1.SetNextCommand(\"build\" /* Build */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindRepairTarget(creep) {\n    const targets = creep.room.find(FIND_STRUCTURES, {\n        filter: (structure => structure.hits < structure.hitsMax)\n    });\n    if (targets.length > 0) {\n        const target = targets.reduce((pre, cur) => {\n            if (pre.hits < 1000 && cur.hits < 1000) {\n                return pre < cur ? pre : cur;\n            }\n            else {\n                if (pre.hits < 1000) {\n                    return pre;\n                }\n                if (cur.hits < 1000) {\n                    return cur;\n                }\n                return pre.hits / pre.hitsMax < cur.hits / cur.hitsMax ?\n                    pre : cur;\n            }\n        });\n        command_1.SetNextCommand(\"repair\" /* Repair */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindUpgradeTarget(creep) {\n    if (creep.room.controller) {\n        command_1.SetNextCommand(\"updateController\" /* UpgradeController */, creep);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nconst cmds = [\"updateController\" /* UpgradeController */, \"build\" /* Build */, \"repair\" /* Repair */];\nconst fns = [FindUpgradeTarget, FindBuildTarget, FindRepairTarget];\nfunction FindNextWork(creep) {\n    const counts = [0, 0, 0];\n    const rest = [];\n    const workers = __1.creepInfo.get(\"worker\" /* Worker */);\n    if (workers) {\n        cmds.forEach((cmd, index) => {\n            const l = workers.get(cmd);\n            if (l) {\n                counts[index] = l.length;\n            }\n        });\n    }\n    const index = cmds.indexOf(creep.memory.cmd.type);\n    if (index >= 0) {\n        counts[index]--;\n    }\n    for (let i = 0; i < counts.length; i++) {\n        if (counts[i] === 0) {\n            const result = fns[i](creep);\n            if (result) {\n                return true;\n            }\n        }\n        else {\n            rest.push(i);\n        }\n    }\n    let id = util_1.RandomObjectInList(rest);\n    while (id !== null) {\n        const result = fns[id](creep);\n        if (result) {\n            return true;\n        }\n        const index = rest.indexOf(id);\n        rest.splice(index, 1);\n        id = util_1.RandomObjectInList(rest);\n    }\n    return false;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GetRequiredEnergy = exports.RandomObjectInList = exports.RandomInt = void 0;\n/**\n * 随机整数\n * @param max 最大值\n * @param min 最小值,默认为0\n * @return 随机结果\n */\nfunction RandomInt(max, min = 0) {\n    return min + Math.floor(Math.random() * (max - min));\n}\nexports.RandomInt = RandomInt;\n/**\n * 在列表中随机一个元素\n * @param list 列表\n * @return 列表长度为0,返回null,反之返回随机的元素\n */\nfunction RandomObjectInList(list) {\n    if (list.length > 0) {\n        return list[Math.floor(Math.random() * list.length)];\n    }\n    else {\n        return null;\n    }\n}\nexports.RandomObjectInList = RandomObjectInList;\n/**\n * 获取对应组件所需的能量\n * @param body 组件列表\n * @return 所及能量\n */\nfunction GetRequiredEnergy(body) {\n    return body.reduce((pre, cur) => {\n        return pre + BODYPART_COST[cur];\n    }, 0);\n}\nexports.GetRequiredEnergy = GetRequiredEnergy;\n"],"sourceRoot":""}