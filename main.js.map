{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/command/build.ts","webpack:///./src/command/command.ts","webpack:///./src/command/harvest.ts","webpack:///./src/command/pickup.ts","webpack:///./src/command/repair.ts","webpack:///./src/command/transfer.ts","webpack:///./src/command/upgradeController.ts","webpack:///./src/command/withdraw.ts","webpack:///./src/config.ts","webpack:///./src/global.ts","webpack:///./src/index.ts","webpack:///./src/moveCache.ts","webpack:///./src/patch.ts","webpack:///./src/strategy/harvester.ts","webpack:///./src/strategy/transferer.ts","webpack:///./src/strategy/worker.ts","webpack:///./src/util.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,GAAG,8CAAM;AAC/E;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO,GAAG,8CAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACI;AACF;AACA;AACI;AACkB;AAClB;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,wDAAe;AAC9C,kDAAkD,4EAAyB;AAC3E,iCAAiC,0DAAgB;AACjD,6BAA6B,sDAAc;AAC3C,iCAAiC,0DAAgB;AACjD,2BAA2B,oDAAa;AACxC,6BAA6B,sDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO,GAAG,8CAAM;AAC9E;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA,uDAAuD,OAAO,GAAG,8CAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAmC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO,GAAG,8CAAM;AAC7E;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO,GAAG,8CAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,GAAG,8CAAM;AAC/E;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO,GAAG,8CAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,GAAG,8CAAM;AAC/E;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO,GAAG,8CAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gEAAgE,OAAO,GAAG,8CAAM;AAChF;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA,mDAAmD,OAAO,GAAG,8CAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,GAAG,8CAAM;AAC/E;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,2DAA2D,OAAO,GAAG,8CAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6DAA6D;;;;;;;;;;;;;ACZpE;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiB;AACC;AAC+B;AACL;AACV;AACU;AACP;AAC0B;AACjB;AACJ;AACS;AACR;AACG;AACN;AACE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAS;AACxB,gBAAgB,+DAAU;AAC1B,YAAY,wDAAM;AAClB;AACA;AACA,aAAa,wDAAO;AACpB,sBAAsB,2EAAgB;AACtC,cAAc,0DAAQ;AACtB,YAAY,sDAAM;AAClB,cAAc,2DAAQ;AACtB,WAAW,qDAAK;AAChB,YAAY,uDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,oBAAoB,iDAAS;AAC7B;AACA;AACA;AACA,uBAAuB,8CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAkB;AACpC;AACA;AACA,wBAAwB,WAAW,GAAG,QAAQ,GAAG,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO,GAAG,8CAAM;AACtE;AACA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACQ;AACiB;AAC7E;AACA;AACA;AACO;AACP,eAAe,+DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,gEAAa;AAC1C,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW;AACjC,qBAAqB,gEAAkB;AACvC;AACA;AACA;AACA,YAAY,uEAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACQ;AACI;AAChE;AACA;AACA;AACO;AACP,eAAe,+DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,gEAAa;AAC1C,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAkB;AACrC;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACQ;AACK;AAC3B;AACtC;AACA;AACA;AACO;AACP,eAAe,+DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,gEAAa;AAC1C,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,+DAA+D,oDAAoD;AACnH;AACA,0DAA0D,0CAA0C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oDAAoD;AAC1G,iDAAiD,0CAA0C;AAC3F;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,gEAAkB;AACrC;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAkB;AAC/B;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import { config } from '../config';\n/**\n * 建造前\n * @param creep Creep\n * @param target 目标\n */\nexport function SetCreepBuild(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 建造\n * @param creep Creep\n */\nexport function Build(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            if (target.progress === target.progressTotal) {\n                if (creep.pos.inRangeTo(target, 3)) {\n                    const result = creep.build(target);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    const result = creep.moveTo(target, { range: 3 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\n","import { SetCreepBuild } from './build';\nimport { SetCreepHarvest } from './harvest';\nimport { SetCreepPickup } from './pickup';\nimport { SetCreepRepair } from './repair';\nimport { SetCreepTransfer } from './transfer';\nimport { SetCreepUpgradeController } from './upgradeController';\nimport { SetCreepWithdraw } from './withdraw';\n/**\n * 设置命令表\n */\nconst SetCommandMap = {\n    [\"harvest\" /* Harvest */]: SetCreepHarvest,\n    [\"updateController\" /* UpgradeController */]: SetCreepUpgradeController,\n    [\"transfer\" /* Transfer */]: SetCreepTransfer,\n    [\"pickup\" /* Pickup */]: SetCreepPickup,\n    [\"withdraw\" /* Withdraw */]: SetCreepWithdraw,\n    [\"build\" /* Build */]: SetCreepBuild,\n    [\"repair\" /* Repair */]: SetCreepRepair,\n};\n/**\n * 设置creep命令\n * @param command 命令\n * @param creep creep\n * @param argv 剩余参数\n */\nexport function SetNextCommand(command, creep, ...argv) {\n    delete creep.memory.cmd;\n    creep.memory.cmd = {\n        type: command\n    };\n    // @ts-expect-error ts暂时无法识别该类型\n    SetCommandMap[command](creep, ...argv);\n}\n","import { config } from '../config';\n/**\n * 收获前\n * @param creep Creep\n * @param target 目标\n */\nexport function SetCreepHarvest(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 收获\n * @param creep Creep\n * @return 收获结果\n */\nexport function Harvest(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (target.energy > 0 || target.ticksToRegeneration < 100) {\n            if (creep.pos.inRangeTo(target.pos, 1)) {\n                if (target.energy > 0) {\n                    const result = creep.harvest(target);\n                    if (result !== OK) {\n                        Game.notify(`harvest fail with code:${result}`, config.notifyInterval);\n                    }\n                }\n                return 0 /* OK */;\n            }\n            else {\n                const result = creep.moveTo(target, { range: 1 });\n                if (result !== OK) {\n                    Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                }\n                return 1 /* Moving */;\n            }\n        }\n        else {\n            return 3 /* TargetNeedReplace */;\n        }\n    }\n    else {\n        return 2 /* TargetLost */;\n    }\n}\n","import { config } from '../config';\nexport function SetCreepPickup(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 捡起\n * @param creep Creep\n */\nexport function Pickup(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n            if (target.amount > 0) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.pickup(target);\n                    if (result !== OK) {\n                        Game.notify(`pickup fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    const result = creep.moveTo(target, { range: 1 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* Full */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\n","import { config } from '../config';\n/**\n * 维修前\n * @param creep Creep\n * @param target 目标\n */\nexport function SetCreepRepair(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 维修\n * @param creep Creep\n */\nexport function Repair(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            if (target.hits === target.hitsMax) {\n                if (creep.pos.inRangeTo(target, 3)) {\n                    const result = creep.repair(target);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    const result = creep.moveTo(target, { range: 3 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\n","import { config } from '../config';\n/**\n * 转移前\n * @param creep Creep\n * @param target 转移目标\n */\nexport function SetCreepTransfer(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 转移\n * @param creep Creep\n */\nexport function Transfer(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.energy > 0) {\n            let hasRest = false;\n            switch (target.structureType) {\n                case STRUCTURE_EXTENSION:\n                case STRUCTURE_SPAWN:\n                case STRUCTURE_TOWER:\n                    hasRest = target.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                    break;\n                case STRUCTURE_CONTAINER:\n                case STRUCTURE_STORAGE:\n                    hasRest = target.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                    break;\n            }\n            if (hasRest) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.transfer(target, RESOURCE_ENERGY);\n                    if (result !== OK) {\n                        Game.notify(`transfer fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    const result = creep.moveTo(target, { range: 1 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* RequireMoreEnergy */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\n","import { config } from '../config';\n/**\n * 升级控制器前\n * @param creep Creep\n */\nexport function SetCreepUpgradeController() {\n    // TODO 暂时没有需要做的\n}\nexport function UpdateController(creep) {\n    if (creep.store.energy > 0) {\n        if (creep.pos.inRangeTo(creep.room.controller, 3)) {\n            const result = creep.upgradeController(creep.room.controller);\n            if (result !== OK) {\n                Game.notify(`upgradeController fail with code:${result}`, config.notifyInterval);\n            }\n            return 0 /* OK */;\n        }\n        else {\n            const result = creep.moveTo(creep.room.controller, { range: 3 });\n            if (result !== OK) {\n                Game.notify(`move fail with code:${result}`, config.notifyInterval);\n            }\n            return 1 /* Moving */;\n        }\n    }\n    else {\n        return 2 /* RequireMoreEnergy */;\n    }\n}\n","import { config } from '../config';\n/**\n * 取回前\n * @param creep Creep\n * @param target 目标\n */\nexport function SetCreepWithdraw(creep, target) {\n    const command = creep.memory.cmd;\n    command.target = target.id;\n}\n/**\n * 取回\n * @param creep Creep\n */\nexport function Withdraw(creep) {\n    const command = creep.memory.cmd;\n    const target = Game.getObjectById(command.target);\n    if (target) {\n        if (creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0) {\n            if (target.store.energy > 0) {\n                if (creep.pos.inRangeTo(target, 1)) {\n                    const result = creep.withdraw(target, RESOURCE_ENERGY);\n                    if (result !== OK) {\n                        Game.notify(`withdraw fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 0 /* OK */;\n                }\n                else {\n                    const result = creep.moveTo(target, { range: 1 });\n                    if (result !== OK) {\n                        Game.notify(`move fail with code:${result}`, config.notifyInterval);\n                    }\n                    return 1 /* Moving */;\n                }\n            }\n            else {\n                return 4 /* TargetNeedReplace */;\n            }\n        }\n        else {\n            return 2 /* Full */;\n        }\n    }\n    else {\n        return 3 /* TargetLost */;\n    }\n}\n","/**\n * 默认配置\n */\nconst defualtConfig = {\n    notifyInterval: 24 * 60,\n    harvester: 3,\n    transferer: 8,\n    worker: 4,\n};\n/**\n * 项目采用配置\n */\nexport const config = Memory.config ? Object.assign(Object.assign({}, defualtConfig), Memory.config) : defualtConfig;\n","var _a, _b;\n/**\n * creep信息\n */\nexport const creepInfo = new Map();\n// 数据预处理\nfor (const creepName in Game.creeps) {\n    const creep = Game.creeps[creepName];\n    let map = creepInfo.get(creep.memory.strategy.type);\n    if (!map) {\n        map = new Map();\n        creepInfo.set(creep.memory.strategy.type, map);\n    }\n    const key = (_b = (_a = creep.memory.cmd) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : null;\n    const list = map.get(key);\n    if (list) {\n        list.push(creep);\n    }\n    else {\n        map.set(key, [creep]);\n    }\n}\n","import './patch';\nimport './global';\nimport { Harvester } from './strategy/harvester';\nimport { Harvest } from './command/harvest';\nimport { config } from './config';\nimport { RandomObjectInList } from './util';\nimport { creepInfo } from './global';\nimport { UpdateController } from './command/upgradeController';\nimport { Transfer } from './command/transfer';\nimport { Pickup } from './command/pickup';\nimport { Transferer } from './strategy/transferer';\nimport { Worker } from './strategy/worker';\nimport { Withdraw } from './command/withdraw';\nimport { Build } from './command/build';\nimport { Repair } from './command/repair';\n// 删除过期数据\nfor (const key in Memory.creeps) {\n    if (!(key in Game.creeps)) {\n        delete Memory.creeps[key];\n    }\n}\n// 数据\nconst strategyMap = {\n    harvester: Harvester,\n    transferer: Transferer,\n    worker: Worker,\n};\nconst commandMap = {\n    harvest: Harvest,\n    updateController: UpdateController,\n    transfer: Transfer,\n    pickup: Pickup,\n    withdraw: Withdraw,\n    build: Build,\n    repair: Repair,\n};\nconst spawn = Game.spawns['Home'];\n// 塔设置\nconst towers = spawn.room.find(FIND_STRUCTURES, {\n    filter: (structure) => structure.structureType === STRUCTURE_TOWER\n        && structure.my\n});\ntowers.forEach(tower => {\n    const hostTile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (hostTile) {\n        hostTile.attack(hostTile);\n    }\n});\n// creep操作\nfor (const name in Game.creeps) {\n    const creep = Game.creeps[name];\n    if (!creep.spawning) {\n        const strategyType = creep.memory.strategy.type;\n        if (creep.memory.cmd) {\n            const commandType = creep.memory.cmd.type;\n            // @ts-expect-error ts暂时无法识别该类型\n            strategyMap[strategyType].callbackMap[commandType](creep, commandMap[commandType](creep));\n        }\n        else {\n            strategyMap[strategyType].start(creep);\n        }\n    }\n}\n// 生成新creep\nif (!spawn.spawning) {\n    let spawing = null;\n    let list = [\"harvester\" /* Harvester */, \"transferer\" /* Transferer */, \"worker\" /* Worker */];\n    for (let i = 0; i < list.length; i++) {\n        const map = creepInfo.get(list[i]);\n        if (map) {\n            let sum = 0;\n            map.forEach(v => sum += v.length);\n            if (sum >= config[list[i]]) {\n                list.splice(i, 1);\n                i--;\n            }\n        }\n        else {\n            spawing = list[i];\n            break;\n        }\n    }\n    if (spawing) {\n        if (spawn.room.energyAvailable < strategyMap[spawing].minEnergy) {\n            spawing = null;\n        }\n    }\n    else {\n        list = list.filter(s => spawn.room.energyAvailable >= strategyMap[s].minEnergy);\n        spawing = RandomObjectInList(list);\n    }\n    if (spawing) {\n        const name = `${spawn.name}-${spawing}-${Game.time}`;\n        const result = spawn.spawnCreep(strategyMap[spawing].create(spawn.room.energyAvailable), name);\n        if (result === OK) {\n            const creep = Game.creeps[name];\n            creep.memory.strategy = {\n                type: spawing\n            };\n            strategyMap[spawing].initStrategy(creep);\n        }\n        else {\n            Game.notify(`spawn creep fail with code:${result}`, config.notifyInterval);\n        }\n    }\n}\n","/**\n * 初始化移动缓存\n * @param creep Creep\n * @return 初始移动缓存数据\n */\nexport function initMoveCache(creep) {\n    return {\n        pos: creep.pos.x + creep.pos.y * 50,\n        ticker: 60,\n    };\n}\n/**\n * 检测移动失效\n * @param creep Creep\n * @param data 移动缓存数据\n * @return 是否失效\n */\nexport function checkMoveFail(creep, data) {\n    const x = data.pos % 50;\n    const y = Math.floor(data.pos / 50);\n    if (creep.pos.inRangeTo(x, y, 3)) {\n        data.ticker--;\n        if (data.ticker <= 0) {\n            data.ticker = 30;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        data.pos = creep.pos.x + creep.pos.y * 50;\n        data.ticker = 30;\n        return false;\n    }\n}\n","\"use strict\";\nGame.killAllCreeps = () => {\n    for (const name in Game.creeps) {\n        Game.creeps[name].suicide();\n        delete Memory.creeps[name];\n    }\n};\nGame.clearRoomInfo = () => {\n    for (const name in Memory.rooms) {\n        delete Memory.rooms[name];\n    }\n};\nGame.Restart = () => {\n    Game.clearRoomInfo();\n    Game.killAllCreeps();\n};\n","import { SetNextCommand } from '../command/command';\nimport { checkMoveFail, initMoveCache } from '../moveCache';\nimport { GetRequiredEnergy, GetRoomInfo, RandomObjectInList } from '../util';\n/**\n * 采集者策略\n */\nexport const Harvester = {\n    minEnergy: GetRequiredEnergy([MOVE, WORK]),\n    create(maxEnergy) {\n        const count = Math.min(4, Math.floor((maxEnergy - this.minEnergy) / BODYPART_COST.work));\n        const body = [MOVE, WORK];\n        body.splice(0, 0, ...new Array(count).fill(WORK));\n        return body;\n    },\n    initStrategy(creep) {\n        const strategy = creep.memory.strategy;\n        strategy.moveCache = initMoveCache(creep);\n    },\n    start(creep) {\n        FindNextTarget(creep);\n    },\n    callbackMap: {\n        [\"harvest\" /* Harvest */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 2 /* TargetLost */:\n                case 3 /* TargetNeedReplace */:\n                    FindNextTarget(creep);\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextTarget(creep);\n                    }\n                    break;\n            }\n        }\n    },\n};\n/**\n * 找到下一个采集目标\n * @param creep creep\n * @return 是否成功\n */\nfunction FindNextTarget(creep) {\n    const roomInfos = GetRoomInfo(creep.room);\n    const sourceId = RandomObjectInList(roomInfos.sourceInfo);\n    if (sourceId) {\n        const target = Game.getObjectById(sourceId);\n        if (target) {\n            SetNextCommand(\"harvest\" /* Harvest */, creep, target);\n            return true;\n        }\n    }\n    creep.say('闲置中');\n    return false;\n}\n","import { SetNextCommand } from '../command/command';\nimport { checkMoveFail, initMoveCache } from '../moveCache';\nimport { GetRequiredEnergy, RandomObjectInList } from '../util';\n/**\n * 运输者\n */\nexport const Transferer = {\n    minEnergy: GetRequiredEnergy([CARRY, MOVE]),\n    create(maxEnergy) {\n        let rest = maxEnergy - this.minEnergy;\n        const body = [CARRY, MOVE];\n        if (rest >= BODYPART_COST.carry) {\n            body.unshift(CARRY);\n            rest -= BODYPART_COST.carry;\n        }\n        const count = Math.floor(rest / (BODYPART_COST.carry * 2 + BODYPART_COST.move));\n        for (let i = 0; i < count; i++) {\n            body.push(CARRY, CARRY, MOVE);\n        }\n        return body;\n    },\n    initStrategy(creep) {\n        const strategy = creep.memory.strategy;\n        strategy.moveCache = initMoveCache(creep);\n    },\n    start(creep) {\n        FindPickupTarget(creep);\n    },\n    callbackMap: {\n        [\"pickup\" /* Pickup */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (!FindPickupTarget(creep) && creep.store.energy > 0) {\n                        FindTransferTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindPickupTarget(creep);\n                    }\n                    break;\n                case 2 /* Full */:\n                    FindTransferTarget(creep);\n                    break;\n            }\n        },\n        [\"transfer\" /* Transfer */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (!FindTransferTarget(creep)) {\n                        FindPickupTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindTransferTarget(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindPickupTarget(creep);\n                    break;\n            }\n        },\n    }\n};\n/**\n * 找到下一个捡起目标\n * @param creep creep\n */\nfunction FindPickupTarget(creep) {\n    const target = RandomObjectInList(creep.room.find(FIND_DROPPED_RESOURCES));\n    if (target) {\n        SetNextCommand(\"pickup\" /* Pickup */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\n/**\n * 找到下一个转移目标\n * @param creep creep\n */\nfunction FindTransferTarget(creep) {\n    const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n        filter: (structure => {\n            switch (structure.structureType) {\n                case STRUCTURE_EXTENSION:\n                case STRUCTURE_SPAWN:\n                case STRUCTURE_TOWER:\n                    return structure.my && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                case STRUCTURE_STORAGE:\n                    return structure.my && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n                case STRUCTURE_CONTAINER:\n                    return structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n            }\n            return false;\n        }),\n        range: 1,\n    });\n    if (target) {\n        SetNextCommand(\"transfer\" /* Transfer */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\n","import { SetNextCommand } from '../command/command';\nimport { checkMoveFail, initMoveCache } from '../moveCache';\nimport { GetRequiredEnergy, RandomObjectInList, } from '../util';\nimport { creepInfo } from '../global';\n/**\n * 采集者策略\n */\nexport const Worker = {\n    minEnergy: GetRequiredEnergy([MOVE, WORK]),\n    create(maxEnergy) {\n        const count = Math.min(4, Math.floor((maxEnergy - this.minEnergy) / BODYPART_COST.work));\n        const body = [MOVE, WORK];\n        body.splice(0, 0, ...new Array(count).fill(WORK));\n        return body;\n    },\n    initStrategy(creep) {\n        const strategy = creep.memory.strategy;\n        strategy.moveCache = initMoveCache(creep);\n    },\n    start(creep) {\n        FindWithdrawTarget(creep);\n    },\n    callbackMap: {\n        [\"withdraw\" /* Withdraw */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 3 /* TargetLost */:\n                case 4 /* TargetNeedReplace */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 2 /* Full */:\n                    FindNextWork(creep);\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindRandomWithdrawTarget(creep);\n                    }\n            }\n        },\n        [\"updateController\" /* UpgradeController */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n        [\"build\" /* Build */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 4 /* TargetNeedReplace */:\n                case 3 /* TargetLost */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n        [\"repair\" /* Repair */]: (creep, result) => {\n            const strategy = creep.memory.strategy;\n            switch (result) {\n                case 4 /* TargetNeedReplace */:\n                case 3 /* TargetLost */:\n                    if (creep.store.energy > 0) {\n                        FindNextWork(creep);\n                    }\n                    else {\n                        FindWithdrawTarget(creep);\n                    }\n                    break;\n                case 1 /* Moving */:\n                    if (checkMoveFail(creep, strategy.moveCache)) {\n                        FindNextWork(creep);\n                    }\n                    break;\n                case 2 /* RequireMoreEnergy */:\n                    FindWithdrawTarget(creep);\n                    break;\n            }\n        },\n    },\n};\nfunction FindWithdrawTarget(creep) {\n    let target = creep.pos.findClosestByPath(FIND_TOMBSTONES, { filter: (tombstone) => tombstone.store.energy > 0 });\n    if (target === null) {\n        target = creep.pos.findClosestByPath(FIND_RUINS, { filter: (ruin) => ruin.store.energy > 0 });\n    }\n    if (target === null) {\n        target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n            filter: (structure) => ((structure.structureType === STRUCTURE_CONTAINER)\n                || (structure.structureType === STRUCTURE_STORAGE && structure.my))\n                && structure.store.energy > 0\n        });\n    }\n    if (target) {\n        SetNextCommand(\"withdraw\" /* Withdraw */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindRandomWithdrawTarget(creep) {\n    const targets = creep.room.find(FIND_TOMBSTONES, { filter: (tombstone) => tombstone.store.energy > 0 });\n    targets.push(...creep.room.find(FIND_RUINS, { filter: (ruin) => ruin.store.energy > 0 }));\n    targets.push(...creep.room.find(FIND_STRUCTURES, {\n        filter: (structure) => ((structure.structureType === STRUCTURE_CONTAINER)\n            || (structure.structureType === STRUCTURE_STORAGE && structure.my))\n            && structure.store.energy > 0\n    }));\n    const target = RandomObjectInList(targets);\n    if (target) {\n        SetNextCommand(\"withdraw\" /* Withdraw */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindBuildTarget(creep) {\n    const targets = creep.room.find(FIND_CONSTRUCTION_SITES, {\n        filter: (constructionSite) => constructionSite.progress < constructionSite.progressTotal\n    });\n    if (targets.length > 0) {\n        const target = targets.reduce((pre, cur) => {\n            if (pre.progressTotal < cur.progressTotal / 10) {\n                return pre;\n            }\n            else if (cur.progressTotal < pre.progressTotal / 10) {\n                return cur;\n            }\n            else {\n                return pre.progress / pre.progressTotal > cur.progress / cur.progressTotal ?\n                    pre : cur;\n            }\n        });\n        SetNextCommand(\"build\" /* Build */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindRepairTarget(creep) {\n    const targets = creep.room.find(FIND_STRUCTURES, {\n        filter: (structure => structure.hits < structure.hitsMax)\n    });\n    if (targets.length > 0) {\n        const target = targets.reduce((pre, cur) => {\n            if (pre.hits < 1000 && cur.hits < 1000) {\n                return pre < cur ? pre : cur;\n            }\n            else {\n                if (pre.hits < 1000) {\n                    return pre;\n                }\n                if (cur.hits < 1000) {\n                    return cur;\n                }\n                return pre.hits / pre.hitsMax < cur.hits / cur.hitsMax ?\n                    pre : cur;\n            }\n        });\n        SetNextCommand(\"repair\" /* Repair */, creep, target);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nfunction FindUpgradeTarget(creep) {\n    if (creep.room.controller) {\n        SetNextCommand(\"updateController\" /* UpgradeController */, creep);\n        return true;\n    }\n    else {\n        creep.say('闲置中');\n        return false;\n    }\n}\nconst cmds = [\"updateController\" /* UpgradeController */, \"build\" /* Build */, \"repair\" /* Repair */];\nconst fns = [FindUpgradeTarget, FindBuildTarget, FindRepairTarget];\nfunction FindNextWork(creep) {\n    const counts = [0, 0, 0];\n    const rest = [];\n    const workers = creepInfo.get(\"worker\" /* Worker */);\n    if (workers) {\n        cmds.forEach((cmd, index) => {\n            const l = workers.get(cmd);\n            if (l) {\n                counts[index] = l.length;\n            }\n        });\n    }\n    const index = cmds.indexOf(creep.memory.cmd.type);\n    if (index >= 0) {\n        counts[index]--;\n    }\n    for (let i = 0; i < counts[i]; i++) {\n        if (counts[i] === 0) {\n            const result = fns[i](creep);\n            if (result) {\n                return true;\n            }\n        }\n        else {\n            rest.push(i);\n        }\n    }\n    let id = RandomObjectInList(rest);\n    while (id !== null) {\n        const result = fns[id](creep);\n        if (result) {\n            return true;\n        }\n        const index = rest.indexOf(id);\n        rest.splice(index, 1);\n        id = RandomObjectInList(rest);\n    }\n    return false;\n}\n","/**\n * 随机整数\n * @param max 最大值\n * @param min 最小值,默认为0\n * @return 随机结果\n */\nexport function RandomInt(max, min = 0) {\n    return min + Math.floor(Math.random() * (max - min));\n}\n/**\n * 在列表中随机一个元素\n * @param list 列表\n * @return 列表长度为0,返回null,反之返回随机的元素\n */\nexport function RandomObjectInList(list) {\n    if (list.length > 0) {\n        return list[Math.floor(Math.random() * list.length)];\n    }\n    else {\n        return null;\n    }\n}\n/**\n * 获取对应组件所需的能量\n * @param body 组件列表\n * @return 所及能量\n */\nexport function GetRequiredEnergy(body) {\n    return body.reduce((pre, cur) => {\n        return pre + BODYPART_COST[cur];\n    }, 0);\n}\n/**\n * 获取房间信息\n * @param room 房间\n */\nexport function GetRoomInfo(room) {\n    const name = room.name;\n    if (name in Memory.rooms) {\n        return Memory.rooms[name];\n    }\n    else {\n        const roomData = {\n            sourceInfo: room.find(FIND_SOURCES).map(source => source.id)\n        };\n        Memory.rooms[name] = roomData;\n        return roomData;\n    }\n}\n"],"sourceRoot":""}