{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.ts","webpack:///./src/walker.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAM;AACzC,QAAQ,8CAAM;AACd,QAAQ,8CAAM;AACd;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB,mCAAmC,MAAM;AACzC,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import { Walker } from './walker';\nlet count = 0;\nfor (const creepName in Game.creeps) {\n    const creep = Game.creeps[creepName];\n    if (creep.memory.type === 'worker') {\n        const target = creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE);\n        if (target) {\n            if (creep.harvest(target) === ERR_NOT_IN_RANGE) {\n                creep.moveTo(target);\n            }\n        }\n        count++;\n    }\n    else if (creep.memory.type === Walker.type) {\n        Walker.count++;\n        Walker.tick(creep, creep.room);\n    }\n}\nfor (const spawnName in Game.spawns) {\n    const spawn = Game.spawns[spawnName];\n    if (!spawn.spawning && spawn.store['energy'] >= 200) {\n        if (Walker.count > 0) {\n            const name = `worker_${count}`;\n            const result = spawn.spawnCreep(['work', 'move'], `worker_${count}`);\n            if (result === OK) {\n                Memory.creeps[name].type = 'worker';\n            }\n            else {\n                console.log(result);\n            }\n        }\n        else {\n            const result = Walker.create(spawn, spawn.room);\n            if (result !== OK) {\n                console.log(result);\n            }\n        }\n    }\n}\n","export const Walker = {\n    count: 0,\n    type: \"Walker\" /* Walker */,\n    create(spawn, room) {\n        const result = spawn.spawnCreep(['move'], 'walker');\n        if (result === OK) {\n            Memory.creeps['walker'].type = \"Walker\" /* Walker */;\n        }\n        Memory.creeps['walker'].direction = getNextDirection(spawn.pos, room);\n        return result;\n    },\n    tick(creep, room) {\n        let direction;\n        if (canMove(creep.pos, creep.memory.direction, room)) {\n            direction = creep.memory.direction;\n        }\n        else {\n            direction = getNextDirection(creep.pos, room);\n            creep.memory.direction = direction;\n        }\n        creep.move(direction);\n    }\n};\nfunction canMove(pos, dir, room) {\n    let dx = 0;\n    let dy = 0;\n    switch (dir) {\n        case LEFT:\n        case TOP_LEFT:\n        case BOTTOM_LEFT:\n            dx = -1;\n            break;\n        case RIGHT:\n        case TOP_RIGHT:\n        case BOTTOM_RIGHT:\n            dx = 1;\n            break;\n    }\n    switch (dir) {\n        case TOP:\n        case TOP_LEFT:\n        case TOP_RIGHT:\n            dy = -1;\n            break;\n        case BOTTOM:\n        case BOTTOM_LEFT:\n        case BOTTOM_RIGHT:\n            dy = 1;\n            break;\n    }\n    return validPosition(pos.x + dx, pos.y + dy, room);\n}\nfunction getNextDirection(pos, room) {\n    const dx = [0, 1, 1, 1, 0, -1, -1, -1];\n    const dy = [-1, -1, 0, 1, 1, 1, 0, -1];\n    const indice = [0, 1, 2, 3, 4, 5, 6, 7];\n    const ok = indice.filter(i => {\n        return validPosition(dx[i] + pos.x, dy[i] + pos.y, room);\n    });\n    return (TOP + ok[Math.random() * ok.length]);\n}\nfunction validPosition(x, y, room) {\n    if (x >= 0 && x < 50 && y >= 0 && y < 50) {\n        const result = room.lookAt(x, y);\n        if (result.every(r => r.terrain !== 'wall')) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\n"],"sourceRoot":""}